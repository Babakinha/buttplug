// Buttplug Rust Source Code File - See https://buttplug.io for more info.
//
// Copyright 2016-2019 Nonpolynomial Labs LLC. All rights reserved.
//
// Licensed under the BSD 3-Clause license. See LICENSE file in the project root
// for full license information.

use crate::core::messages::{self, ButtplugMessageUnion};
use super::connector::{ButtplugClientConnector, ButtplugClientConnectorError};
use core::pin::Pin;
use futures::{StreamExt, Future, task::{Waker, Poll, Context}};
use async_std::{sync::{channel, Sender, Receiver}, future::{select}, task};
use std::sync::{Arc, Mutex};

/// Struct used for waiting on replies from the server.
///
/// When a ButtplugMessage is sent to the server, it may take an indeterminate
/// amount of time to get a reply. This struct holds the reply, as well as a
/// [Waker] for the related future. Once the reply_msg is filled, the waker will
/// be called to finish the future polling.
#[derive(Default, Debug, Clone)]
pub struct ButtplugClientMessageState {
    reply_msg: Option<ButtplugMessageUnion>,
    waker: Option<Waker>,
}

impl ButtplugClientMessageState {
    /// Sets the reply message in a message state struct, firing the waker.
    ///
    /// When a reply is received from (or in the in-process case, generated by)
    /// a server, this function takes the message, updates the state struct, and
    /// calls [Waker::wake] so that the corresponding future can finish.
    ///
    /// # Parameters
    ///
    /// - `msg`: Message to set as reply, which will be returned by the
    /// corresponding future.
    pub fn set_reply_msg(&mut self, msg: &ButtplugMessageUnion) {
        self.reply_msg = Some(msg.clone());
        let waker = self.waker.take();
        // TODO This should never happen? If it does we'll just lock because we
        // don't have a future to finish?
        if !waker.is_none() {
            waker.unwrap().wake();
        }
    }
}

/// Shared [ButtplugClientMessageState] type.
///
/// [ButtplugClientMessageState] is made to be shared across futures, and we'll
/// never know if those futures are single or multithreaded. Only needs to
/// unlock for calls to [ButtplugClientMessageState::set_reply_msg].
pub type ButtplugClientMessageStateShared = Arc<Mutex<ButtplugClientMessageState>>;

/// [Future] implementation for [ButtplugMessageUnion] types send to the server.
///
/// A [Future] implementation that we can always expect to return a
/// [ButtplugMessageUnion]. Used to deal with getting server replies after
/// sending [ButtplugMessageUnion] types via the client API.
#[derive(Default, Debug)]
pub struct ButtplugClientMessageFuture {
    /// State that holds the waker for the future, and the [ButtplugMessageUnion] reply (once set).
    ///
    /// ## Notes
    ///
    /// This needs to be an [Arc]<[Mutex]<T>> in order to make it mutable under
    /// pinning when dealing with being a future. There is a chance we could do
    /// this as a [Pin::get_unchecked_mut] borrow, which would be way faster, but
    /// that's dicey and hasn't been proven as needed for speed yet.
    waker_state: ButtplugClientMessageStateShared,
}

impl ButtplugClientMessageFuture {
    /// Creates a new ButtplugClientMessageFuture
    ///
    /// # Parameters
    ///
    /// - `state`: The shared state that the future will rely on for return
    /// values and wakers.
    pub fn new(state: &ButtplugClientMessageStateShared) -> ButtplugClientMessageFuture {
        ButtplugClientMessageFuture {
            waker_state: state.clone(),
        }
    }

    /// Returns a clone of the state, used for moving the state across contexts
    /// (tasks/threads/etc...).
    pub fn get_state_clone(&self) -> ButtplugClientMessageStateShared {
        self.waker_state.clone()
    }

    // TODO Should we implement drop on this, so it'll yell if its dropping and
    // the waker didn't fire? otherwise it seems like we could have quiet
    // deadlocks.
}

impl Future for ButtplugClientMessageFuture {
    type Output = ButtplugMessageUnion;

    /// Returns when the [ButtplugMessageUnion] reply has been set in the
    /// [ButtplugClientMessageStateShared].
    fn poll(self: Pin<&mut Self>, cx: &mut Context) -> Poll<Self::Output> {
        let mut waker_state = self.waker_state.lock().unwrap();
        if waker_state.reply_msg.is_some() {
            let msg = waker_state.reply_msg.take().unwrap();
            Poll::Ready(msg)
        } else {
            debug!("Waker set.");
            waker_state.waker = Some(cx.waker().clone());
            Poll::Pending
        }
    }
}

/// The internal event loop for the [ButtplugClient].
///
/// Created whenever a new [ButtplugClient] is created, the internal loop
/// handles connection and communication with the server, and creation of events
/// received from the server. As [ButtplugClient] is clonable, multiple
/// ButtplugClient instances can exist that all communicate with the same
/// [ButtplugClientInternalLoop].
///
/// Also, if multiple [ButtplugClient] instances are created via new(), multiple
/// [ButtplugClientInternalLoop]s can run in parallel. This allows applications
/// to possibly create connections to multiple [ButtplugServer] instances.
pub struct ButtplugClientInternalLoop {
    /// List of currently connected device ids
    connected_devices: Vec<u32>,
    /// Connector struct, which handles communication with the server
    connector: Option<Box<dyn ButtplugClientConnector>>,
    /// Receiver for data from the connector
    connector_receiver: Option<Receiver<ButtplugMessageUnion>>,
    /// Receiver for data from clients
    client_receiver: Receiver<ButtplugInternalClientMessage>,
    /// Sender for communicating events to [ButtplugClient]s
    event_sender: Sender<ButtplugMessageUnion>,
}

unsafe impl Send for ButtplugClientInternalLoop {}

pub enum ButtplugInternalClientMessage {
    Connect(Box<dyn ButtplugClientConnector>, ButtplugClientMessageStateShared),
    Disconnect,
    Message((ButtplugMessageUnion, ButtplugClientMessageStateShared)),
}

pub enum ButtplugInternalDeviceMessage {
    Message,
}

impl ButtplugClientInternalLoop {
    pub fn new(event_sender: Sender<ButtplugMessageUnion>,
               client_receiver: Receiver<ButtplugInternalClientMessage>) -> Self {
        ButtplugClientInternalLoop {
            connector: None,
            connected_devices: vec!(),
            connector_receiver: None,
            client_receiver,
            event_sender,
        }
    }

    pub async fn wait_for_event(&mut self) -> Option<ButtplugClientConnectorError> {
        info!("Starting client event loop.");
        let mut r = None;
        if let Some(ref mut recv) = self.connector_receiver {
            //event_future = recv.clone().next().fuse();
            r = Some(recv.clone());
        }
        let mut event_recv = None;
        if let Some(ref mut re) = r {
            event_recv = Some(re.clone());
        }
        enum StreamReturn {
            ConnectorMessage(ButtplugMessageUnion),
            ClientMessage(ButtplugInternalClientMessage),
            Disconnect,
        }
        let mut client_receiver = self.client_receiver.clone();
        let client = task::spawn(async move {
            let val = client_receiver.next().await;
            if val.is_none() {
                StreamReturn::Disconnect
            } else {
                StreamReturn::ClientMessage(val.unwrap())
            }
        });
        let mut stream_ret;
        if let Some(mut er) = event_recv {
            info!("Waiting on event and client!");
            let event = task::spawn(async move {
                let val = er.next().await;
                if val.is_none() {
                    StreamReturn::Disconnect
                } else {
                    StreamReturn::ConnectorMessage(val.unwrap())
                }
            });
            stream_ret = select!(event, client).await;
        } else {
            info!("Waiting on client!");
            stream_ret = client.await;
        }
        match stream_ret {
            StreamReturn::ConnectorMessage(_msg) => {
                info!("Sending message to clients!");
                self.event_sender.send(_msg.clone()).await;
                None
            },
            StreamReturn::ClientMessage(_msg) => {
                match _msg {
                    ButtplugInternalClientMessage::Connect(mut connector, mut state) => {
                        match connector.connect().await {
                            Some(_s) => {
                                None //return Result::Err(ButtplugClientError::ButtplugClientConnectorError(_s)),
                            },
                            None => {
                                info!("Connected!");
                                let mut waker_state = state.lock().unwrap();
                                waker_state.set_reply_msg(&ButtplugMessageUnion::Ok(messages::Ok::new(1)));
                                self.connector_receiver = Some(connector.get_event_receiver());
                                self.connector = Option::Some(connector);
                                None
                            }
                        }
                    },
                    ButtplugInternalClientMessage::Message(_msg_fut) => {
                        if let Some(ref mut connector) = self.connector {
                            connector.send(&_msg_fut.0, &_msg_fut.1).await;
                        }
                        None
                    },
                    _ => panic!("Message not handled!")
                }
            },
            StreamReturn::Disconnect => {
                info!("Disconnected!");
                None
            }
        }
    }
}

